# пакет научных и инженерных библиотек, статистических и других методов(из пакета scipy класс stats)
import scipy.stats as st
import itertools  # Функции создания итераторов для эффективных циклов
# строится поверх библиотеки NumPy, являющейся инструментом более низкого уровня.
import pandas as pd
# Предоставляет специальные структуры данных и операции для манипулирования числовыми таблицами и временными рядами
import matplotlib.pyplot as plt  # предназначена для создания научной графики
import seaborn as sns  # пакет визуализации различными графиками
import numpy as np  # набор процедур для быстрых операций с массивами, включая математические, логические, манипуляции с формами, сортировку, выбор, ввод-вывод. ,
# дискретные преобразования Фурье, базовая линейная алгебра, базовые статистические операции, случайное моделирование и многое другое
""" for n in range(1, 11):
    a = abs(pow(-1, n)*n**2)
    b = abs(pow(n, pow(-1, n)))
    c = abs(pow(2, pow(n, 1/3)))
    d = abs(pow(n, pow(-1, n)*n))
    e = abs(pow(1/2, (pow(-1, n)-1)*n))
    print("{}; {}; {}; {}; {};\n".format(a, b, c, d, e)) """

""" Программа симуляции многократного сравнения Хср m выборок по n элементов из 1 норм ГС, на предмет t-критерием проверки
гипотезы Н0 с границей Р < 0.05 - но в случае когда выборок много, количество случаев с Р > 0.05  растет (для 2х = 5 %)
пропорционально количеству парных сравнений = m*(m-1)/2. Поправка Банферони предлагает уменьшать границу Р < 0.05/(m*(m-1)/2)
Данная поправка слишком сильно режет - лучше использовать другие "поправки на множественные значения"! """
M = 0
D = 1


def ttest(a, b):
    se = np.sqrt(a['SD']**2/a['N'] + b['SD']**2/b['N'])
    t = (a['Mx'] - b['Mx'])/se
    dfreedom = a['N'] + b['N'] - 2
    return st.t.sf(np.abs(t), dfreedom)*2

# n - элементов в выборке
# m - количество выборок
# a -  вероятность


def false_alarm(m, n, a):
    trys = 1000  # количество экспериментов
    hist = {'Да': 0, 'Нет': 0}  # результаты сравнений
    data = list(range(m))  # инициализация групп с выборками

    # запускаем trys экспериментов
    for i in range(trys):

        # наполняем m выборок, для ускорения сразу их агрегируем по SD, Mx, N
        for j in range(m):
            dt = st.norm.rvs(loc=M, scale=D, size=n)
            data[j] = {'SD': np.std(dt, ddof=1), 'Mx': np.mean(dt), 'N': n}

        # сравниваем выборки по 2 группы, перебор можно реализовать с помощью двух циклов или воспользоваться itertools
        for first, second in itertools.combinations(data, 2):
            if ttest(first, second) <= a:
                hist['Да'] += 1
                break
        else:
            hist['Нет'] += 1

    # рисуем гитограмму частот
    barlist = plt.bar(hist.keys(), hist.values(), color='b')
    barlist[0].set_color('r')
    plt.title(round(hist['Да'] / trys, 3))
    plt.ylabel('количество')
    plt.show()


false_alarm(2, 30, 0.05)


# Меры центральной тенденции
# Мода числа - самый распространенный член выборки, подключаем from scipy import stats, import numpy
a = [185, 175, 170, 169, 171, 172, 175, 157, 170, 172, 167, 173, 168, 167, 166,
     167, 169, 172, 177, 178, 165, 161, 179, 159, 164, 178, 172, 170, 173, 171]

mode = st.mode(a)
print(mode)

# медиана - центральное значение упорядоченной выборки (если нечет - берется конкретное, если чет - среднее из двух центральных)
median = np.median(a)
print(median)
# среднее значение - арифм среднее
mean = np.mean(a)
print(mean)
'''Расчёт моды, медианы и среднего с помощью библиотеки pandas'''

sample = pd.Series([185, 175, 170, 169, 171, 175, 157, 172, 170, 172, 167, 173,
                    167, 169, 172, 177, 178, 165, 161, 179, 159, 164, 178, 172, 170, ])
print('mode:', sample.mode())
print('median:', sample.median())
print('mean:', sample.mean())


# Меры изменчивости
# размах - Это разность между максимальным и минимальным значение распределения
print("размах: ", np.ptp(a))
print("min: ", np.nanmin(a))
print("max: ", np.nanmax(a))

# дисперсия - среднее квадратное отклонение от среднего значения
# дисперсия
print(np.var(a))
# дисперсия (N - 1)
# ddof - дельта степеней свободы, для уточнения дисперсии = 1
print(np.var(a, ddof=1))
# Среднее квадратичное отклонение (стандартное отклонение - корень квадратный от дисперсии)
print(np.std(a))
# Среднее квадратичное (N - 1)
print(np.std(a, ddof=1))

koef = [1, 5, 2, 7, 1, 9, 3, 8, 5, 9]
# дисперсия (N - 1)
print("дисперсия (N - 1):", np.var(koef, ddof=1))
# среднее значение - арифм среднее
print("арифм среднее:", np.mean(koef))
# Среднее квадратичное (N - 1)
print("Среднее квадратичное (N - 1):", np.std(koef, ddof=1))

""" Кванти́ли - это такие значения признака, которые делят упорядоченные данные на некоторое число равных частей
Медиана - на 2 равные части
Квартили распределения - 3 точки, делящие наши данные на 4 части
 """
# реализация графика ящик с усами(свечи - медиана, квартели, макс, мин, размах)
ax = sns.boxplot(y=a)
# реализация графика рой точек (распределение выборки)
ax = sns.swarmplot(y=a, color="#00ffa6")
print(ax)
""" Альтернатива через pyplot
plt.boxplot(sample, showfliers=1)
plt.show() """


# создание нормального распределения
# создаем пустой словарь распределения { ключ1:значение1, x:y, ....}
a = {}
# кидаем 1000 шариков
for i in range(1000):
    # первоначально шарик летит по центру
    x = 0
    # создадим 20 препятствий - шарик отскочит либо налево (-1), либо направо (+1)
    for j in range(20):
        # random.choice в numpy с равной вероятностью выдает один из элементов массива
        x += np.random.choice([-1, 1])
    # приземляем шарик к колодец, в зависимости от того, куда она отскочил
    # (заполняем словарь по ключу х прибавляем значение+1)
    a[x] = a.get(x, 0) + 1
# визуализация
sns.set()
# по х - покажем индексы наших колодцев,
# по оси y - сколько шариков в них оказалось
sns.barplot(x=list(a.keys()), y=list(a.values()))
# plt.show()  # визуализация всех графиков

# реализация расчета z критерия члена нормального распределения,
# и вероятности значения больше point (если Z(i)>0) и меньше его (если Z(i)<0)
# значение члена у которого считаем Z(i)
point = [70, 112]
probability_of_point = []
# среднее мат ожидание
mean = 100
# стандратное отклонение (корень из дисперсии)
std = 15
for point in point:
    z = (point - mean) / std

    if point > mean:
        # вероятность значения больше point (Z(i)>0)
        probability_of_point.append(1 - st.norm.cdf(z))
    else:
        # вероятность значений меньше point (Z(i)<0)
        probability_of_point.append(st.norm.cdf(z))
    print(z)
    print(f'{round(probability_of_point[-1]*100, 2)}%')
probability_of_point_midle = 1-probability_of_point[0]-probability_of_point[1]
print(f'{round(probability_of_point_midle*100, 2)}%')


""" # критерий стьюдента, сравнение двух выборок, чтобы понять из одной они ГС или разных
array1 = [84.7, 105.0, 98.9, 97.9, 108.7, 81.3, 99.4, 89.4, 93.0,
          119.3, 99.2, 99.4, 97.1, 112.4, 99.8, 94.7, 114.0, 95.1, 115.5, 111.5]
array2 = [57.2, 68.6, 104.4, 95.1, 89.9, 70.8, 83.5, 60.1, 75.7,
          102.0, 69.0, 79.6, 68.9, 98.6, 76.0, 74.8, 56.0, 55.6, 69.4, 59.5]

# считаем количество элементов, среднее, стандартное отклонение и стандартную ошибку
df = pd.DataFrame({'Выборка1': array1, 'Выборка2': array2}).agg(
    ['mean', 'std', 'count', 'sem']).transpose()
df.columns = ['Mx', 'SD', 'N', 'SE']

# рассчитываем 95% интервал отклонения среднего
p = 0.95
K = st.t.ppf(p+(1 - p)/2, df['N']-1)
df['interval'] = K * df['SE']

# строим графики, boxplot из изначальных данных array1, array2,  доверительные интервалы из датафрейма df
fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(14, 9))

# график boxplot
bplot1 = ax1.boxplot([array1, array2],
                     vert=True,  # создаем вертикальные боксы
                     patch_artist=True,  # для красоты заполним цветом боксы квантилей
                     labels=['Выборка1', 'Выборка2'])  # используется для задания значений выборок в случае с boxplot

# график доверительных интервалов
bplot2 = ax2.errorbar(x=df.index, y=df['Mx'], yerr=df['interval'],
                      color="black", capsize=3, marker="s", markersize=4, mfc="red", mec="black", fmt='o')

# раскрасим boxplot
colors = ['pink', 'lightgreen']
for patch, color in zip(bplot1['boxes'], colors):
    patch.set_facecolor(color)

# добавим общие для каждого из графиков данные
for ax in [ax1, ax2]:
    ax.yaxis.grid(True)
    ax.set_title('Температура плавления ДНК двух типов')
    ax.set_xlabel('Сравнение двух выборок')
    ax.set_ylabel('Температура F')

plt.show() """
